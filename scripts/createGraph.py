import pandas as pd
import json
import community
# from networkx.algorithms import community
import networkx as nx
from networkx.algorithms.community import greedy_modularity_communities
import pandas as pd
import random
import numpy as np
import randomcolor

import config as CONFIG

"""When calling this function make sure you give it a .json extension for g_export argument"""
def generate_graph(nodes_df, links_df, g_export='graph.json', set_size=None):
    """
    Args:
        nodes_df: dataframe representing the nodes
        links_df: dataframe representing the links
        set_size: num representing a subset amount of the data frames
        g_export: str representing the name of the exported json - placed here to name the graph based on features

    Generate a subset of nodes and edges
    graph = {
        "nodes" : [...],
        "links": [...]
    }

    returns a json file structured as the dict graph
    """

    # select how many rows you want to get from the column
    nodes_dict = nodes_df[:set_size].to_dict(orient='index').values()
    links_dict = links_df[:set_size].to_dict(orient='index').values()

    # convert it to an array of dicts
    nodes_array = [i for i in nodes_dict]
    links_array = [i for i in links_dict]

    # setup format for json later
    graph = {
        'nodes': nodes_array,
        'links': links_array
    }

    g = ''

    if set_size != None:
        print(f"Generating subset graph with of size {set_size} ")
        # naming of the graph json file
        graph_file_name = CONFIG.new_data_folder / 'subsetGraph.json'
        g = graph_file_name

    else:
        print("Generating graph json")
        # naming of the graph json file
        graph_file_name = CONFIG.new_data_folder / g_export
        print("Completed! check your DIR")
        g = graph_file_name

    # write the dataframe to json
    with open(g, 'w') as file:
        json.dump(graph, file)


def community_graph(links_df, original_df, g_export='graph.json'):
    """ Function to create json file based on communities generated by nx

    Args:
        links_df (pandas dataframe): The dataframe on which we will create the graph from
        original_df (pandas ddataframe): dataframe of the nodes

    returns:
        A dataframe that represents the nodes with a unique group_id and color

    """

    print("Creating a nodes dataframe representing the nodes with a unique group ids and colors")

    # clean up column names accordingly
    links_df = links_df.rename(columns={"target": "source", "neighbor": "target"})

    # define graph
    """ change: source='target' and target='neighbor' """
    g = nx.from_pandas_edgelist(links_df, source='source', target='target')

    # compute the best partition
    G = g
    c = list(greedy_modularity_communities(G))

    # identify communities
    num_nodes = 0
    for community in c:
        num_nodes += len(community)

    partition = community.best_partition(G)

    # merge the groupids onto the df
    partition_items = partition.items()
    df_with_groupids = pd.DataFrame(partition_items, columns=['Code', 'group_id'])

    # get edges only where source and target nodes belong to a valid community for now
    # nodes_in_communities = df_with_groupids['Code'].unique()
    # edges_for_community_nodes_df = links_df.loc[links_df['source'].isin(nodes_in_communities) & links_df['target'].isin(nodes_in_communities)]

    # merge unique ids onto the original dataframe
    # df_merged = df_with_groupids.merge(original_df, how='right', on=['Code'])

    # add a unique color
    # unique_community_ids = df_merged['group_id'].unique()

    # color_dict = []
    # for groupid in unique_community_ids:
    #     #generate a random color
    #     color = randomcolor.RandomColor().generate()[0]
    #     color_dict.append({'group_id': groupid, 'color_code': color})

    # # create a dataframe from the color and unique id
    # color_df = pd.DataFrame(color_dict)

    # # merge that dataframe witht he original
    # df_merged_with_color = df_merged.merge(color_df, how='right', on=['group_id'])

    # return df_merged_with_color
